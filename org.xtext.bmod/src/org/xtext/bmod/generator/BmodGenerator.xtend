/*
 * generated by Xtext 2.16.0
 */
package org.xtext.bmod.generator

import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.bmod.bmod.Coordinate
import org.xtext.bmod.bmod.Door
import org.xtext.bmod.bmod.Exit
import org.xtext.bmod.bmod.Fire
import org.xtext.bmod.bmod.Floorplan
import org.xtext.bmod.bmod.Import
import org.xtext.bmod.bmod.Person
import org.xtext.bmod.bmod.Room

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BmodGenerator implements IGenerator2 {
	
	private static def String removeExtension(String s) {
	
	    val separator = System.getProperty("file.separator");
	    var filename = "";
	
	    // Remove the path upto the filename.
	    var lastSeparatorIndex = s.lastIndexOf(separator);
	    if (lastSeparatorIndex == -1) {
	        filename = s;
	    } else {
	        filename = s.substring(lastSeparatorIndex + 1);
	    }
	
	    // Remove the extension.
	    var extensionIndex = filename.lastIndexOf(".");
	    if (extensionIndex == -1)
	        return filename;
	
	    return filename.substring(0, extensionIndex);
	}
	
	private def void generateCMakeLists(String project_name, List<String> lst, IFileSystemAccess2 fsa) {
		val pedsim_lib = "/usr/include/libpedsim";
		fsa.generateFile('''«project_name»/CMakeLists.txt''', '''
			cmake_minimum_required(VERSION 3.1)
			set(PROJECT_NAME sim«project_name»)
			project(${PROJECT_NAME})
			set(CMAKE_CXX_STANDARD 11)
			set(PEDSIM_LIB «pedsim_lib»)
			
			file(GLOB_RECURSE SRC ../simulation/*)
			«IF !lst.empty»
				list(APPEND SRC
				«FOR elm: lst»
					"«elm»"
				«ENDFOR»
				)
			«ENDIF»
			
			add_executable(${PROJECT_NAME} main.cpp ${SRC})
			target_include_directories(${PROJECT_NAME} PUBLIC ${PEDSIM_LIB})
			target_include_directories(${PROJECT_NAME} PUBLIC ../)
			target_link_libraries(${PROJECT_NAME} ${PEDSIM_LIB}/libpedsim.so)
		''');
	}
	
	private def void generateSimulationLibrary(IFileSystemAccess2 fsa) {
		var lst = <String>newArrayList();
		val dir = "simulation";
		val files = CppGenerationHelper.files;
		
		var iter = files.entrySet.iterator;
		while(iter.hasNext) {
			var pair = iter.next
			lst.add(dir + "/" + pair.key);
			fsa.generateFile(lst.last, pair.value);
		}
		
		for(var i = 0; i < lst.size; i++) {
			lst.set(i, "../" + lst.get(i));
		}
	}
	
	private def double compX(Pair<Coordinate, Coordinate> bounds, double x) {
		val middleX = (bounds.value.x - bounds.key.x) / 2;
		return x - middleX;
	}
	
	private def double compY(Pair<Coordinate, Coordinate> bounds, double y) {
		val middleY = (bounds.value.y - bounds.key.y) / 2;
		return y - middleY;
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {	
		val simpleClassName = resource.getURI.trimFileExtension.lastSegment
		if(resource.contents?.head === null) {
			return;
		}
		val floorplan = resource.contents.head.eContents;
		val scale = 1.0;
		val floor = resource.contents.filter(Floorplan).get(0);
		val bounds = Helper.getFloorplanBoundaries(floor);
		
		var floorcells = 0;
		for(room: floor.rooms) {
			floorcells += Helper.getRoomCoords(room).size;
		}
		
		fsa.generateFile(simpleClassName + '/main.cpp', '''
			#include "ped_includes.h"
			
			#include <iostream>
			#include <sstream>
			#include <unistd.h>
			#include <utility>
			
			#include "simulation/cell.h"
			#include "simulation/door.h"
			#include "simulation/floor.h"
			#include "simulation/person.h"
			
			«FOR imp: floorplan.filter(Import)»
				#include "«removeExtension(imp.importURI)»/targetters.h"
			«ENDFOR»
			
			using namespace std;
			using namespace simulation;
			
			Person* newAgent(Ped::Tscene* scene, double x, double y, const Floor& floor) {
				Person* p = new Person(x, y, «scale / 2», floor);
				scene->addAgent(p->get());
				return p;
			}
			
			void drawLocation(Cell* cell, Ped::OutputWriter* ow, double red, double green, double blue) {
				Ped::Tvector c1(cell->x, cell->y);
				Ped::Tvector c2(cell->x + «scale», cell->y + «scale»);
				Ped::Tvector c3(cell->x, cell->y + «scale»);
				Ped::Tvector c4(cell->x + «scale», cell->y);
				
				// Draw cross
				ow->drawLine(c1, c2, 1, red, green, blue);
				ow->drawLine(c3, c4, 1, red, green, blue);
			}
			
			
			int main(int argc, char *argv[]) {
				
				cout << "# PedSim Simulation of '«simpleClassName»' using libpedsim version " << Ped::LIBPEDSIM_VERSION << endl;
				
				// Setup
				Ped::Tscene *pedscene = new Ped::Tscene();
				
				// create an output writer which will send output to a visualizer
				Ped::OutputWriter *ow = new Ped::UDPOutputWriter();
				ow->setScenarioName("«simpleClassName»");
				pedscene->setOutputWriter(ow);
				
				// Create floorplan
				vector<pair<Cell*, Cell*>> obstacles;
				Floor floor;
				floor.scale = «scale»;
				vector<Cell*> room;
				«FOR room: floorplan.filter(Room)»
					«FOR ob: Helper.getRoomObstacles(room, floor)»
						obstacles.emplace_back(make_pair<Cell*, Cell*>(new Cell(«bounds.compX(ob.key.x) * scale», «bounds.compY(ob.key.y) * scale»), new Cell(«bounds.compX(ob.value.x) * scale», «bounds.compY(ob.value.y) * scale»)));
					«ENDFOR»
					room = {};
					«FOR cell: Helper.getRoomCoords(room)»
						room.emplace_back(new Cell(«bounds.compX(cell.x) * scale», «bounds.compY(cell.y) * scale»));
					«ENDFOR»
					floor.rooms.emplace_back(room);
					«IF room.hasCapacity»
						floor.capacities.insert(std::make_pair<unsigned long, unsigned long>(«floorplan.filter(Room).toList.indexOf(room)», «room.capacity»));
					«ENDIF»
				«ENDFOR»
				room = {};
				for(const auto& obstacle: obstacles) {
					pedscene->addObstacle(new Ped::Tobstacle(obstacle.first->x, obstacle.first->y, obstacle.second->x, obstacle.second->y));
				}
				
				// Set exits
				«FOR exit: floorplan.filter(Exit)»
					floor.setExit(«bounds.compX(exit.location.x) * scale», «bounds.compY(exit.location.y) * scale»);
				«ENDFOR»
				
				// Draw doors
				«FOR door: Helper.sortDoors(floor)»
					floor.doors.emplace_back(new Door(«bounds.compX(door.from.x) * scale», «bounds.compY(door.from.y) * scale», «bounds.compX(door.to.x) * scale», «bounds.compY(door.to.y) * scale»));
				«ENDFOR»
				for(Door* door: floor.doors) {
					door->draw(ow, «scale»);
				}
				
				// Fire
				«FOR fire: floorplan.filter(Fire)»
					floor.at(«bounds.compX(fire.location.x) * scale», «bounds.compY(fire.location.y) * scale»)->onfire = true;
				«ENDFOR»
				
				for(const std::vector<Cell*>& room: floor.rooms) {
					for(Cell* cell: room) {
						if(cell->onfire) {
							drawLocation(cell, ow, 1, 0, 0);
						} else if(cell->exit) {
							drawLocation(cell, ow, 0, 1, 0);
						}
					}
				}
				
				// Create people
				«FOR person: floorplan.filter(Person)»
					floor.people.emplace_back(newAgent(pedscene, «bounds.compX(person.location.x) * scale», «bounds.compY(person.location.y) * scale», floor));
					floor.people.back()->registerTargetter(targetters::action_«person.action.name», targetters::action_«person.action.name»_shared);
				«ENDFOR»
				
				// convenience
				const vector<Ped::Tagent*>& myagents = pedscene->getAllAgents();
				const vector<Ped::Tobstacle*>& myobstacles = pedscene->getAllObstacles();
				
				// Metrics
				ow->writeMetrics({
					{"Timestep", "0"},
					{"Ignited Cells", "0"},
					{"Burning (Percentage)", "0"},
					{"Escaped People", "0"},
					{"Death People", "0"},
					{"Room Capacities Violated", "0"}
				});
				
				// simulation loop
				pedscene->moveAgents(0.4);
				long int time = 0;
				vector<Cell*> fire = floor.find([](const Cell* c) { return c->onfire; });
				while(fire.size() < «floorcells» && floor.find([](const Person* p) { return p->isAlive() && !p->hasEscaped(); }).size() > 0) {
					++time;
					ow->writeTimeStep(time);
					// Delay for next step
					// char c;
					// cin >> c;
					usleep(500*1000);
					
					// Compute agent movement
					for(Person* person: floor.people) {
						person->target();
					}
					// Move all agents
				    long int timestep = 0;
				    int notreached = myagents.size();
				    pedscene->moveAgents(1);
				    
				    // Spread Fire
				    vector<Cell*> to_add;
					for(auto f: fire) {
						Cell* right = new Cell(f->x + «scale», f->y);
						if(f->canSpread(right, floor, fire, to_add)) {
							to_add.emplace_back(right);
						}
						
						Cell* left = new Cell(f->x - «scale», f->y);
						if(f->canSpread(left, floor, fire, to_add)) {
							to_add.emplace_back(left);
						}
						
						Cell* top = new Cell(f->x, f->y - «scale»); 
						if(f->canSpread(top, floor, fire, to_add)) {
							to_add.emplace_back(top);
						}
						
						Cell* bottom = new Cell(f->x, f->y + «scale»);
						if(f->canSpread(bottom, floor, fire, to_add)) {
							to_add.emplace_back(bottom);
						}
					}
					for(auto f: to_add) {
						Cell* loc = floor.at(f->x, f->y);
						loc->onfire = true;
						fire.emplace_back(loc);
					}
					for(const std::vector<Cell*>& room: floor.rooms) {
						for(Cell* cell: room) {
							if(cell->onfire) {
								drawLocation(cell, ow, 1, 0, 0);
							} else if(cell->exit) {
								drawLocation(cell, ow, 0, 1, 0);
							}
						}
					}
					
					for(Door* door: floor.doors) {
						door->draw(ow, «scale»);
					}
					
					pedscene->moveAgents(0); //< Somehow this is necessary to draw all the obstacles correctly.
					
					// Clear escaped persons
					for(Person* p: floor.people) {
						if(p->hasEscaped()) {
							pedscene->removeAgent(p->get());
						}
					}
					
					// Check Capacities
					int caps = 0;
					for(const auto& cap: floor.capacities) {
						if(floor.find([](const Person* p) { return p->isAlive() && !p->hasEscaped(); }, floor.rooms.at(cap.first).front()).size() > cap.second) {
							++caps;
						}
					}
					
					// Metrics
					ow->writeMetrics({
						{"Timestep", std::to_string(time)},
						{"Ignited Cells", std::to_string(fire.size())},
						{"Burning (Percentage)", std::to_string((double)fire.size() / (double)«floorcells»)},
						{"Escaped People", std::to_string(floor.people.size() - myagents.size())},
						{"Death People", std::to_string(floor.people.size() - floor.find([](const Person* p) { return p->isAlive(); }).size())},
						{"Room Capacities Violated", std::to_string(caps)}
					});
				}
				
				// cleanup
				for (auto a : pedscene->getAllAgents()) { delete a; };
				for (auto w : pedscene->getAllWaypoints()) { delete w; };
				for (auto o : pedscene->getAllObstacles()) { delete o; };
				for (auto c : fire) { delete c; }
				for (auto p : floor.people) { delete p; }
				for (auto d : floor.doors) { delete d; }
				delete pedscene;
				
				return EXIT_SUCCESS;
			}
		''');
		
		generateSimulationLibrary(fsa);
		var lst = newArrayList();
		for(imp: floorplan.filter(Import)) {
			lst.add('''../«removeExtension(imp.importURI)»/targetters.h''');
			lst.add('''../«removeExtension(imp.importURI)»/targetters.cpp''');
		}
		generateCMakeLists(simpleClassName, lst, fsa);
	}

//	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		// Generate simulation package
//		val files = GenerationHelper.files;
//		files.forEach[key, value| fsa.generateFile(key, value);];
//		
//		val simpleClassName = resource.getURI.trimFileExtension.lastSegment
//		if(resource.contents?.head === null) {
//			return;
//		}
//		val floorplan = resource.contents.head.eContents;
//		
//		fsa.generateFile(simpleClassName + '.java', '''
//			import org.bmod.helper.Operations;
//			
//			import org.bmod.simulation.Cell;
//			import org.bmod.simulation.Door;
//			import org.bmod.simulation.EmergencySign;
//			import org.bmod.simulation.Person;
//			import org.bmod.simulation.Room;
//			import org.bmod.simulation.Simulatable;
//			import org.bmod.simulation.Simulator;
//			
//			import java.util.ArrayList;
//			
//			public class «simpleClassName» {
//				public static void main(String... args) {
//					ArrayList<Simulatable> list = new ArrayList<Simulatable>();
//					
//					// Rooms and Cells
//					«FOR room: floorplan.filter(Room)»
//						Room room_«room.name» = new Room();
//						«FOR cell: Helper.getRoomCoords(room)»
//							Cell cell_«cell.x»_«cell.y» = new Cell(«cell.x», «cell.y»);
//							«FOR exit: floorplan.filter(Exit)»
//								«IF exit.location.x == cell.x && exit.location.y == cell.y»
//									cell_«cell.x»_«cell.y».setExit(true);
//								«ENDIF»
//							«ENDFOR»
//							«FOR fire: floorplan.filter(Fire)»
//								«IF fire.location.x == cell.x && fire.location.y == cell.y»
//									cell_«cell.x»_«cell.y».ignite();
//								«ENDIF»
//							«ENDFOR»
//							room_«room.name».add(cell_«cell.x»_«cell.y»);
//							list.add(cell_«cell.x»_«cell.y»);
//						«ENDFOR»
//						list.add(room_«room.name»);
//						
//					«ENDFOR»
//					
//					// Doors
//					«FOR door: floorplan.filter(Door)»
//						Door door_«door.name» = new Door(«door.from.x», «door.from.y», «door.to.x», «door.to.y»);
//						door_«door.name».setup(list);
//						list.add(door_«door.name»);
//						
//					«ENDFOR»
//					
//					// Emergency Signs
//					«FOR sign: floorplan.filter(EmergencySign)»
//						EmergencySign sign_«sign.on.name»_«sign.to.ref.name» = new EmergencySign(door_«sign.on.name», door_«sign.to.ref.name»);
//						sign_«sign.on.name»_«sign.to.ref.name».setup(list);
//						list.add(sign_«sign.on.name»_«sign.to.ref.name»);
//						
//					«ENDFOR»
//					
//					// Actions and Perceptions
//					«FOR action: floorplan.filter(ActionProfile)»
//						Person.actions.put("«action.name»", (Person p, ArrayList<Simulatable> o) -> { Operations.action_«action.name»(p, o); });
//					«ENDFOR»
//					«FOR perception: floorplan.filter(PerceptionLevel)»
//						Person.perceptions.put("«perception.name»", (Person p, ArrayList<Simulatable> o) -> { return Operations.perception_«perception.name»(p, o); });
//					«ENDFOR»
//					
//					// Persons
//					«FOR person: floorplan.filter(Person)»
//						«IF person.action.existing !== null»
//							«IF person.perception.existing !== null»
//							Person person_«person.name» = new Person("«person.named»", «person.location.x», «person.location.y», "«person.perception.existing.getName»", "«person.action.existing.getName»");
//							«ELSE»
//							Person person_«person.name» = new Person("«person.named»", «person.location.x», «person.location.y», "«person.perception.custom.toString»", "«person.action.existing.getName»");
//							«ENDIF»
//						«ELSE»
//							«IF person.perception.existing !== null»
//							Person person_«person.name» = new Person("«person.named»", «person.location.x», «person.location.y», "«person.perception.existing.getName»", "«person.action.custom.toString»");
//							«ELSE»
//							Person person_«person.name» = new Person("«person.named»", «person.location.x», «person.location.y», "«person.perception.custom.toString»", "«person.action.custom.toString»");
//							«ENDIF»
//						«ENDIF»
//						list.add(person_«person.name»);
//					«ENDFOR»
//					
//					// Simulation itself
//					new Simulator(list);
//				}
//			}
//		''');
//		
//	}
	
	override afterGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	override beforeGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
}