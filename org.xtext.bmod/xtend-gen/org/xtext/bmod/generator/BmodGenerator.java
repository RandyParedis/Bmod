/**
 * generated by Xtext 2.16.0
 */
package org.xtext.bmod.generator;

import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGenerator2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.xtext.bmod.bmod.Coordinate;
import org.xtext.bmod.bmod.Door;
import org.xtext.bmod.bmod.Exit;
import org.xtext.bmod.bmod.Fire;
import org.xtext.bmod.bmod.Floorplan;
import org.xtext.bmod.bmod.Import;
import org.xtext.bmod.bmod.Person;
import org.xtext.bmod.bmod.Room;
import org.xtext.bmod.generator.CppGenerationHelper;
import org.xtext.bmod.generator.Helper;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BmodGenerator implements IGenerator2 {
  private static String removeExtension(final String s) {
    final String separator = System.getProperty("file.separator");
    String filename = "";
    int lastSeparatorIndex = s.lastIndexOf(separator);
    if ((lastSeparatorIndex == (-1))) {
      filename = s;
    } else {
      filename = s.substring((lastSeparatorIndex + 1));
    }
    int extensionIndex = filename.lastIndexOf(".");
    if ((extensionIndex == (-1))) {
      return filename;
    }
    return filename.substring(0, extensionIndex);
  }
  
  private void generateCMakeLists(final String project_name, final List<String> lst, final IFileSystemAccess2 fsa) {
    final String pedsim_lib = "/usr/include/libpedsim";
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(project_name);
    _builder.append("/CMakeLists.txt");
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append("cmake_minimum_required(VERSION 3.1)");
    _builder_1.newLine();
    _builder_1.append("set(PROJECT_NAME sim");
    _builder_1.append(project_name);
    _builder_1.append(")");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("project(${PROJECT_NAME})");
    _builder_1.newLine();
    _builder_1.append("set(CMAKE_CXX_STANDARD 11)");
    _builder_1.newLine();
    _builder_1.append("set(PEDSIM_LIB ");
    _builder_1.append(pedsim_lib);
    _builder_1.append(")");
    _builder_1.newLineIfNotEmpty();
    _builder_1.newLine();
    _builder_1.append("file(GLOB_RECURSE SRC ../simulation/*)");
    _builder_1.newLine();
    {
      boolean _isEmpty = lst.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder_1.append("list(APPEND SRC");
        _builder_1.newLine();
        {
          for(final String elm : lst) {
            _builder_1.append("\"");
            _builder_1.append(elm);
            _builder_1.append("\"");
            _builder_1.newLineIfNotEmpty();
          }
        }
        _builder_1.append(")");
        _builder_1.newLine();
      }
    }
    _builder_1.newLine();
    _builder_1.append("add_executable(${PROJECT_NAME} main.cpp ${SRC})");
    _builder_1.newLine();
    _builder_1.append("target_include_directories(${PROJECT_NAME} PUBLIC ${PEDSIM_LIB})");
    _builder_1.newLine();
    _builder_1.append("target_include_directories(${PROJECT_NAME} PUBLIC ../)");
    _builder_1.newLine();
    _builder_1.append("target_link_libraries(${PROJECT_NAME} ${PEDSIM_LIB}/libpedsim.so)");
    _builder_1.newLine();
    fsa.generateFile(_builder.toString(), _builder_1);
  }
  
  private void generateSimulationLibrary(final IFileSystemAccess2 fsa) {
    try {
      ArrayList<String> lst = CollectionLiterals.<String>newArrayList();
      final String dir = "simulation";
      final Map<String, String> files = CppGenerationHelper.files();
      Iterator<Map.Entry<String, String>> iter = files.entrySet().iterator();
      while (iter.hasNext()) {
        {
          Map.Entry<String, String> pair = iter.next();
          String _key = pair.getKey();
          String _plus = ((dir + "/") + _key);
          lst.add(_plus);
          fsa.generateFile(IterableExtensions.<String>last(lst), pair.getValue());
        }
      }
      for (int i = 0; (i < lst.size()); i++) {
        String _get = lst.get(i);
        String _plus = ("../" + _get);
        lst.set(i, _plus);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private double compX(final Pair<Coordinate, Coordinate> bounds, final double x) {
    int _x = bounds.getValue().getX();
    int _x_1 = bounds.getKey().getX();
    int _minus = (_x - _x_1);
    final int middleX = (_minus / 2);
    return (x - middleX);
  }
  
  private double compY(final Pair<Coordinate, Coordinate> bounds, final double y) {
    int _y = bounds.getValue().getY();
    int _y_1 = bounds.getKey().getY();
    int _minus = (_y - _y_1);
    final int middleY = (_minus / 2);
    return (y - middleY);
  }
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final String simpleClassName = resource.getURI().trimFileExtension().lastSegment();
    EList<EObject> _contents = resource.getContents();
    EObject _head = null;
    if (_contents!=null) {
      _head=IterableExtensions.<EObject>head(_contents);
    }
    boolean _tripleEquals = (_head == null);
    if (_tripleEquals) {
      return;
    }
    final EList<EObject> floorplan = IterableExtensions.<EObject>head(resource.getContents()).eContents();
    final double scale = 1.0;
    final Floorplan floor = ((Floorplan[])Conversions.unwrapArray(Iterables.<Floorplan>filter(resource.getContents(), Floorplan.class), Floorplan.class))[0];
    final Pair<Coordinate, Coordinate> bounds = Helper.getFloorplanBoundaries(floor);
    int floorcells = 0;
    EList<Room> _rooms = floor.getRooms();
    for (final Room room : _rooms) {
      int _floorcells = floorcells;
      int _size = Helper.getRoomCoords(room).size();
      floorcells = (_floorcells + _size);
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#include \"ped_includes.h\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include <iostream>");
    _builder.newLine();
    _builder.append("#include <sstream>");
    _builder.newLine();
    _builder.append("#include <unistd.h>");
    _builder.newLine();
    _builder.append("#include <utility>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("#include \"simulation/cell.h\"");
    _builder.newLine();
    _builder.append("#include \"simulation/door.h\"");
    _builder.newLine();
    _builder.append("#include \"simulation/floor.h\"");
    _builder.newLine();
    _builder.append("#include \"simulation/person.h\"");
    _builder.newLine();
    _builder.newLine();
    {
      Iterable<Import> _filter = Iterables.<Import>filter(floorplan, Import.class);
      for(final Import imp : _filter) {
        _builder.append("#include \"");
        String _removeExtension = BmodGenerator.removeExtension(imp.getImportURI());
        _builder.append(_removeExtension);
        _builder.append("/targetters.h\"");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("using namespace std;");
    _builder.newLine();
    _builder.append("using namespace simulation;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("Person* newAgent(Ped::Tscene* scene, double x, double y, const Floor& floor) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Person* p = new Person(x, y, ");
    _builder.append((scale / 2), "\t");
    _builder.append(", floor);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("scene->addAgent(p->get());");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return p;");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("void drawLocation(Cell* cell, Ped::OutputWriter* ow, double red, double green, double blue) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Ped::Tvector c1(cell->x, cell->y);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Ped::Tvector c2(cell->x + ");
    _builder.append(scale, "\t");
    _builder.append(", cell->y + ");
    _builder.append(scale, "\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("Ped::Tvector c3(cell->x, cell->y + ");
    _builder.append(scale, "\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("Ped::Tvector c4(cell->x + ");
    _builder.append(scale, "\t");
    _builder.append(", cell->y);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Draw cross");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ow->drawLine(c1, c2, 1, red, green, blue);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ow->drawLine(c3, c4, 1, red, green, blue);");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.newLine();
    _builder.append("int main(int argc, char *argv[]) {");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("cout << \"# PedSim Simulation of \'");
    _builder.append(simpleClassName, "\t");
    _builder.append("\' using libpedsim version \" << Ped::LIBPEDSIM_VERSION << endl;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Setup");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Ped::Tscene *pedscene = new Ped::Tscene();");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// create an output writer which will send output to a visualizer");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Ped::OutputWriter *ow = new Ped::UDPOutputWriter();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ow->setScenarioName(\"");
    _builder.append(simpleClassName, "\t");
    _builder.append("\");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pedscene->setOutputWriter(ow);");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Create floorplan");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("vector<pair<Cell*, Cell*>> obstacles;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Floor floor;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("floor.scale = ");
    _builder.append(scale, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("vector<Cell*> room;");
    _builder.newLine();
    {
      Iterable<Room> _filter_1 = Iterables.<Room>filter(floorplan, Room.class);
      for(final Room room_1 : _filter_1) {
        {
          ArrayList<Pair<Coordinate, Coordinate>> _roomObstacles = Helper.getRoomObstacles(room_1, floor);
          for(final Pair<Coordinate, Coordinate> ob : _roomObstacles) {
            _builder.append("\t");
            _builder.append("obstacles.emplace_back(make_pair<Cell*, Cell*>(new Cell(");
            double _compX = this.compX(bounds, ob.getKey().getX());
            double _multiply = (_compX * scale);
            _builder.append(_multiply, "\t");
            _builder.append(", ");
            double _compY = this.compY(bounds, ob.getKey().getY());
            double _multiply_1 = (_compY * scale);
            _builder.append(_multiply_1, "\t");
            _builder.append("), new Cell(");
            double _compX_1 = this.compX(bounds, ob.getValue().getX());
            double _multiply_2 = (_compX_1 * scale);
            _builder.append(_multiply_2, "\t");
            _builder.append(", ");
            double _compY_1 = this.compY(bounds, ob.getValue().getY());
            double _multiply_3 = (_compY_1 * scale);
            _builder.append(_multiply_3, "\t");
            _builder.append(")));");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("room = {};");
        _builder.newLine();
        {
          ArrayList<Coordinate> _roomCoords = Helper.getRoomCoords(room_1);
          for(final Coordinate cell : _roomCoords) {
            _builder.append("\t");
            _builder.append("room.emplace_back(new Cell(");
            double _compX_2 = this.compX(bounds, cell.getX());
            double _multiply_4 = (_compX_2 * scale);
            _builder.append(_multiply_4, "\t");
            _builder.append(", ");
            double _compY_2 = this.compY(bounds, cell.getY());
            double _multiply_5 = (_compY_2 * scale);
            _builder.append(_multiply_5, "\t");
            _builder.append("));");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("floor.rooms.emplace_back(room);");
        _builder.newLine();
        {
          boolean _isHasCapacity = room_1.isHasCapacity();
          if (_isHasCapacity) {
            _builder.append("\t");
            _builder.append("floor.capacities.insert(std::make_pair<unsigned long, unsigned long>(");
            int _indexOf = IterableExtensions.<Room>toList(Iterables.<Room>filter(floorplan, Room.class)).indexOf(room_1);
            _builder.append(_indexOf, "\t");
            _builder.append(", ");
            int _capacity = room_1.getCapacity();
            _builder.append(_capacity, "\t");
            _builder.append("));");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("\t");
    _builder.append("room = {};");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for(const auto& obstacle: obstacles) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("pedscene->addObstacle(new Ped::Tobstacle(obstacle.first->x, obstacle.first->y, obstacle.second->x, obstacle.second->y));");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Set exits");
    _builder.newLine();
    {
      Iterable<Exit> _filter_2 = Iterables.<Exit>filter(floorplan, Exit.class);
      for(final Exit exit : _filter_2) {
        _builder.append("\t");
        _builder.append("floor.setExit(");
        double _compX_3 = this.compX(bounds, exit.getLocation().getX());
        double _multiply_6 = (_compX_3 * scale);
        _builder.append(_multiply_6, "\t");
        _builder.append(", ");
        double _compY_3 = this.compY(bounds, exit.getLocation().getY());
        double _multiply_7 = (_compY_3 * scale);
        _builder.append(_multiply_7, "\t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Draw doors");
    _builder.newLine();
    {
      ArrayList<Door> _sortDoors = Helper.sortDoors(floor);
      for(final Door door : _sortDoors) {
        _builder.append("\t");
        _builder.append("floor.doors.emplace_back(new Door(");
        double _compX_4 = this.compX(bounds, door.getFrom().getX());
        double _multiply_8 = (_compX_4 * scale);
        _builder.append(_multiply_8, "\t");
        _builder.append(", ");
        double _compY_4 = this.compY(bounds, door.getFrom().getY());
        double _multiply_9 = (_compY_4 * scale);
        _builder.append(_multiply_9, "\t");
        _builder.append(", ");
        double _compX_5 = this.compX(bounds, door.getTo().getX());
        double _multiply_10 = (_compX_5 * scale);
        _builder.append(_multiply_10, "\t");
        _builder.append(", ");
        double _compY_5 = this.compY(bounds, door.getTo().getY());
        double _multiply_11 = (_compY_5 * scale);
        _builder.append(_multiply_11, "\t");
        _builder.append("));");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("for(Door* door: floor.doors) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("door->draw(ow, ");
    _builder.append(scale, "\t\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Fire");
    _builder.newLine();
    {
      Iterable<Fire> _filter_3 = Iterables.<Fire>filter(floorplan, Fire.class);
      for(final Fire fire : _filter_3) {
        _builder.append("\t");
        _builder.append("floor.at(");
        double _compX_6 = this.compX(bounds, fire.getLocation().getX());
        double _multiply_12 = (_compX_6 * scale);
        _builder.append(_multiply_12, "\t");
        _builder.append(", ");
        double _compY_6 = this.compY(bounds, fire.getLocation().getY());
        double _multiply_13 = (_compY_6 * scale);
        _builder.append(_multiply_13, "\t");
        _builder.append(")->onfire = true;");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for(const std::vector<Cell*>& room: floor.rooms) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(Cell* cell: room) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(cell->onfire) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("drawLocation(cell, ow, 1, 0, 0);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("} else if(cell->exit) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("drawLocation(cell, ow, 0, 1, 0);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Create people");
    _builder.newLine();
    {
      Iterable<Person> _filter_4 = Iterables.<Person>filter(floorplan, Person.class);
      for(final Person person : _filter_4) {
        _builder.append("\t");
        _builder.append("floor.people.emplace_back(newAgent(pedscene, ");
        double _compX_7 = this.compX(bounds, person.getLocation().getX());
        double _multiply_14 = (_compX_7 * scale);
        _builder.append(_multiply_14, "\t");
        _builder.append(", ");
        double _compY_7 = this.compY(bounds, person.getLocation().getY());
        double _multiply_15 = (_compY_7 * scale);
        _builder.append(_multiply_15, "\t");
        _builder.append(", floor));");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("floor.people.back()->registerTargetter(targetters::action_");
        String _name = person.getAction().getName();
        _builder.append(_name, "\t");
        _builder.append(", targetters::action_");
        String _name_1 = person.getAction().getName();
        _builder.append(_name_1, "\t");
        _builder.append("_shared);");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// convenience");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const vector<Ped::Tagent*>& myagents = pedscene->getAllAgents();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("const vector<Ped::Tobstacle*>& myobstacles = pedscene->getAllObstacles();");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// Metrics");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("ow->writeMetrics({");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Timestep\", \"0\"},");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Ignited Cells\", \"0\"},");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Burning (Percentage)\", \"0\"},");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Escaped People\", \"0\"},");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Death People\", \"0\"},");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("{\"Room Capacities Violated\", \"0\"}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// simulation loop");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("pedscene->moveAgents(0.4);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("long int time = 0;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("vector<Cell*> fire = floor.find([](const Cell* c) { return c->onfire; });");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("while(fire.size() < ");
    _builder.append(floorcells, "\t");
    _builder.append(" && floor.find([](const Person* p) { return p->isAlive() && !p->hasEscaped(); }).size() > 0) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("++time;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ow->writeTimeStep(time);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Delay for next step");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// char c;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// cin >> c;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("usleep(500*1000);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Compute agent movement");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(Person* person: floor.people) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("person->target();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Move all agents");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("long int timestep = 0;");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("int notreached = myagents.size();");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("pedscene->moveAgents(1);");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("// Spread Fire");
    _builder.newLine();
    _builder.append("\t    ");
    _builder.append("vector<Cell*> to_add;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(auto f: fire) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Cell* right = new Cell(f->x + ");
    _builder.append(scale, "\t\t\t");
    _builder.append(", f->y);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("if(f->canSpread(right, floor, fire, to_add)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("to_add.emplace_back(right);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Cell* left = new Cell(f->x - ");
    _builder.append(scale, "\t\t\t");
    _builder.append(", f->y);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("if(f->canSpread(left, floor, fire, to_add)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("to_add.emplace_back(left);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Cell* top = new Cell(f->x, f->y - ");
    _builder.append(scale, "\t\t\t");
    _builder.append("); ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("if(f->canSpread(top, floor, fire, to_add)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("to_add.emplace_back(top);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Cell* bottom = new Cell(f->x, f->y + ");
    _builder.append(scale, "\t\t\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("if(f->canSpread(bottom, floor, fire, to_add)) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("to_add.emplace_back(bottom);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(auto f: to_add) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Cell* loc = floor.at(f->x, f->y);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("loc->onfire = true;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("fire.emplace_back(loc);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(const std::vector<Cell*>& room: floor.rooms) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("for(Cell* cell: room) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("if(cell->onfire) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("drawLocation(cell, ow, 1, 0, 0);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("} else if(cell->exit) {");
    _builder.newLine();
    _builder.append("\t\t\t\t\t");
    _builder.append("drawLocation(cell, ow, 0, 1, 0);");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(Door* door: floor.doors) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("door->draw(ow, ");
    _builder.append(scale, "\t\t\t");
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("pedscene->moveAgents(0); //< Somehow this is necessary to draw all the obstacles correctly.");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Clear escaped persons");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(Person* p: floor.people) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(p->hasEscaped()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("pedscene->removeAgent(p->get());");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Check Capacities");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("int caps = 0;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for(const auto& cap: floor.capacities) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if(floor.find([](const Person* p) { return p->isAlive() && !p->hasEscaped(); }, floor.rooms.at(cap.first).front()).size() > cap.second) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("++caps;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Metrics");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ow->writeMetrics({");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{\"Timestep\", std::to_string(time)},");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{\"Ignited Cells\", std::to_string(fire.size())},");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{\"Burning (Percentage)\", std::to_string((double)fire.size() / (double)");
    _builder.append(floorcells, "\t\t\t");
    _builder.append(")},");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("{\"Escaped People\", std::to_string(floor.people.size() - myagents.size())},");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{\"Death People\", std::to_string(floor.people.size() - floor.find([](const Person* p) { return p->isAlive(); }).size())},");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("{\"Room Capacities Violated\", std::to_string(caps)}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("});");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("// cleanup");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto a : pedscene->getAllAgents()) { delete a; };");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto w : pedscene->getAllWaypoints()) { delete w; };");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto o : pedscene->getAllObstacles()) { delete o; };");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto c : fire) { delete c; }");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto p : floor.people) { delete p; }");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("for (auto d : floor.doors) { delete d; }");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("delete pedscene;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("return EXIT_SUCCESS;");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    fsa.generateFile((simpleClassName + "/main.cpp"), _builder);
    this.generateSimulationLibrary(fsa);
    ArrayList<String> lst = CollectionLiterals.<String>newArrayList();
    Iterable<Import> _filter_5 = Iterables.<Import>filter(floorplan, Import.class);
    for (final Import imp_1 : _filter_5) {
      {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("../");
        String _removeExtension_1 = BmodGenerator.removeExtension(imp_1.getImportURI());
        _builder_1.append(_removeExtension_1);
        _builder_1.append("/targetters.h");
        lst.add(_builder_1.toString());
        StringConcatenation _builder_2 = new StringConcatenation();
        _builder_2.append("../");
        String _removeExtension_2 = BmodGenerator.removeExtension(imp_1.getImportURI());
        _builder_2.append(_removeExtension_2);
        _builder_2.append("/targetters.cpp");
        lst.add(_builder_2.toString());
      }
    }
    this.generateCMakeLists(simpleClassName, lst, fsa);
  }
  
  @Override
  public void afterGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  @Override
  public void beforeGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
}
