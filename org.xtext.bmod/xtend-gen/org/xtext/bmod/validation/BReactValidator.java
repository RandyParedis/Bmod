/**
 * generated by Xtext 2.16.0
 */
package org.xtext.bmod.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.xtext.bmod.breact.ActionDesc;
import org.xtext.bmod.breact.BreactPackage;
import org.xtext.bmod.breact.Distance;
import org.xtext.bmod.breact.Find;
import org.xtext.bmod.breact.Locatable;
import org.xtext.bmod.breact.React;
import org.xtext.bmod.validation.AbstractBReactValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BReactValidator extends AbstractBReactValidator {
  public static final String BURNING_CELL = "burningCell";
  
  public static final String BURNING_FIRE = "burningFire";
  
  public static final String NORMAL_FIRE = "normalFire";
  
  public static final String EXCESSIVE_FROM = "excessiveFrom";
  
  @Check
  public void checkBurningCell(final Find find) {
    if ((find.isBurning() && Objects.equal(find.getLocatable(), Locatable.CELL))) {
      this.warning("Finding a burning Cell is the same as finding a Fire", BreactPackage.Literals.FIND__BURNING, BReactValidator.BURNING_CELL);
    }
  }
  
  @Check
  public void checkBurningFire(final Find find) {
    if ((find.isBurning() && Objects.equal(find.getLocatable(), Locatable.FIRE))) {
      this.warning("Useless keyword \'burning\'", BreactPackage.Literals.FIND__BURNING, BReactValidator.BURNING_FIRE);
    } else {
      if ((find.isNormal() && Objects.equal(find.getLocatable(), Locatable.FIRE))) {
        this.error("Invalid keyword \'normal\' for Fire", BreactPackage.Literals.FIND__NORMAL, BReactValidator.NORMAL_FIRE);
      }
    }
  }
  
  @Check
  public void checkUniqueNames(final React react) {
    final ArrayList<String> lst = CollectionLiterals.<String>newArrayList();
    EList<ActionDesc> _actions = react.getActions();
    for (final ActionDesc action : _actions) {
      boolean _contains = lst.contains(action.getName());
      if (_contains) {
        this.error("There already exists an action with this name", action, null);
      } else {
        lst.add(action.getName());
      }
    }
  }
  
  @Check
  public void checkSimilarFinds(final ActionDesc action) {
    final ArrayList<Find> lst = CollectionLiterals.<Find>newArrayList();
    EList<Find> _finds = action.getFinds();
    for (final Find find : _finds) {
      {
        boolean found = false;
        for (final Find c : lst) {
          if ((((((c.isGlobal() == find.isGlobal()) && Objects.equal(c.getDistance(), find.getDistance())) && 
            (c.isBurning() == find.isBurning())) && (c.isNormal() == find.isNormal())) && 
            Objects.equal(c.getLocatable(), find.getLocatable()))) {
            this.warning("Duplicate find statement", find, null);
            found = true;
          }
        }
        if ((!found)) {
          lst.add(find);
        }
      }
    }
  }
  
  @Check
  public void checkExcessiveFrom(final Find find) {
    if ((find.isFrom() && (!Objects.equal(find.getDistance(), Distance.FARTHEST)))) {
      this.warning("The keyword \'from\' only makes sense when used together with \'farthest\'", BreactPackage.Literals.FIND__FROM, BReactValidator.EXCESSIVE_FROM);
    }
  }
}
