/**
 * generated by Xtext 2.16.0
 */
package org.xtext.bmod.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.xtext.bmod.Helper;
import org.xtext.bmod.bmod.Area;
import org.xtext.bmod.bmod.Coordinate;
import org.xtext.bmod.bmod.Door;
import org.xtext.bmod.bmod.Floorplan;
import org.xtext.bmod.bmod.Room;
import org.xtext.bmod.validation.AbstractBmodValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BmodValidator extends AbstractBmodValidator {
  @Check
  public void checkAreaTopLeftToBottomRight(final Area area) {
    if (((area.getFrom().getX() > area.getTo().getX()) || (area.getFrom().getY() > area.getTo().getY()))) {
      this.error("Area must be defined from top-left to bottom-right", area, null);
    }
  }
  
  @Check
  public void checkAreaAllCellsConnected(final Area area) {
    final ArrayList<Coordinate> coords = Helper.getAreaCoords(area);
    boolean _isEmpty = coords.isEmpty();
    if (_isEmpty) {
      this.error("Area must contain cells", area, null);
    } else {
      ArrayList<Coordinate> set = CollectionLiterals.<Coordinate>newArrayList(coords.get(0));
      for (int i = 0; (i < set.size()); i++) {
        for (final Coordinate c : coords) {
          if ((Helper.neighbouring(c, set.get(i)) && (!Helper.isIn(c, set)))) {
            set.add(c);
          }
        }
      }
      int _size = set.size();
      int _size_1 = coords.size();
      boolean _notEquals = (_size != _size_1);
      if (_notEquals) {
        this.error("Area has disconnected cells", area, null);
      }
    }
  }
  
  @Check
  public void checkRoomsNoOverlap(final Floorplan fp) {
    EList<Room> _rooms = fp.getRooms();
    for (final Room a : _rooms) {
      EList<Room> _rooms_1 = fp.getRooms();
      for (final Room b : _rooms_1) {
        if (((!Objects.equal(a, b)) && Helper.areIntersecting(Helper.getAreaCoords(a.getArea()), Helper.getAreaCoords(b.getArea())))) {
          this.error("Rooms are overlapping", b, null);
        }
      }
    }
  }
  
  @Check
  public void checkDoorCellsNeighbouring(final Door door) {
    boolean _neighbouring = Helper.neighbouring(door.getFrom(), door.getTo());
    boolean _not = (!_neighbouring);
    if (_not) {
      this.error("The cells of the door must be neighbouring", door, null);
    }
  }
  
  @Check
  public void checkDoorCellsDifferentRooms(final Floorplan fp) {
    EList<Room> _rooms = fp.getRooms();
    for (final Room room : _rooms) {
      {
        final ArrayList<Coordinate> cells = Helper.getAreaCoords(room.getArea());
        EList<Door> _doors = fp.getDoors();
        for (final Door door : _doors) {
          if ((Helper.isIn(door.getFrom(), cells) && Helper.isIn(door.getTo(), cells))) {
            this.error("The cells of the door must be in different rooms", door, null);
          }
        }
      }
    }
  }
}
