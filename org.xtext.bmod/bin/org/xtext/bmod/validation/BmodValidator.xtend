/*
 * generated by Xtext 2.16.0
 */
package org.xtext.bmod.validation

import org.eclipse.xtext.validation.Check
import org.xtext.bmod.Helper
import org.xtext.bmod.bmod.Area
import org.xtext.bmod.bmod.Door
import org.xtext.bmod.bmod.Floorplan

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BmodValidator extends AbstractBmodValidator {
	@Check
	def void checkAreaTopLeftToBottomRight(Area area) {
		if(area.from.x > area.to.x || area.from.y > area.to.y) {
			error("Area must be defined from top-left to bottom-right", area, null);
		}
	}
	
	@Check
	def void checkAreaAllCellsConnected(Area area) {
		// Create the Cell List
		val coords = Helper.getAreaCoords(area);
				
		if(coords.empty) {
			error("Area must contain cells", area, null);
		} else {
			// Do Floodfill to check if all cells are connected
			var set = newArrayList(coords.get(0));
			
			for(var i = 0; i < set.size; i++) {
				for(c: coords) {
					if(Helper.neighbouring(c, set.get(i)) && !Helper.isIn(c, set)) {
						set.add(c);
					}
				}
			}
			if(set.size != coords.size) {
				error("Area has disconnected cells", area, null);
			}
		}
	}
	
	@Check
	def void checkRoomsNoOverlap(Floorplan fp) {
		for(a: fp.rooms) {
			for(b: fp.rooms) {
				if(a != b && Helper.areIntersecting(Helper.getAreaCoords(a.area), Helper.getAreaCoords(b.area))) {
					error("Rooms are overlapping", b, null);
				}
			}
		}
	}
	
	@Check
	def void checkDoorCellsNeighbouring(Door door) {
		if(!Helper.neighbouring(door.from, door.to)) {
			error("The cells of the door must be neighbouring", door, null);
		}
	}
	
	@Check
	def void checkDoorCellsDifferentRooms(Floorplan fp) {
		for(room: fp.rooms) {
			val cells = Helper.getAreaCoords(room.area);
			for(door: fp.doors) {
				if(Helper.isIn(door.from, cells) && Helper.isIn(door.to, cells)) {
					error("The cells of the door must be in different rooms", door, null);
				}
			}
		}
	}
}
